var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        var y = cwd || '.';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = (function () {
    var queue = [];
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;
    
    if (canPost) {
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);
    }
    
    return function (fn) {
        if (canPost) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        }
        else setTimeout(fn, 0);
    };
})();

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

require.define("path", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("/node_modules/expect.js/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./expect\"}\n//@ sourceURL=/node_modules/expect.js/package.json"
));

require.define("/node_modules/expect.js/expect.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "\n(function (global, module) {\n\n  if ('undefined' == typeof module) {\n    var module = { exports: {} }\n      , exports = module.exports\n  }\n\n  /**\n   * Exports.\n   */\n\n  module.exports = expect;\n  expect.Assertion = Assertion;\n\n  /**\n   * Exports version.\n   */\n\n  expect.version = '0.1.2';\n\n  /**\n   * Possible assertion flags.\n   */\n\n  var flags = {\n      not: ['to', 'be', 'have', 'include', 'only']\n    , to: ['be', 'have', 'include', 'only', 'not']\n    , only: ['have']\n    , have: ['own']\n    , be: ['an']\n  };\n\n  function expect (obj) {\n    return new Assertion(obj);\n  }\n\n  /**\n   * Constructor\n   *\n   * @api private\n   */\n\n  function Assertion (obj, flag, parent) {\n    this.obj = obj;\n    this.flags = {};\n\n    if (undefined != parent) {\n      this.flags[flag] = true;\n\n      for (var i in parent.flags) {\n        if (parent.flags.hasOwnProperty(i)) {\n          this.flags[i] = true;\n        }\n      }\n    }\n\n    var $flags = flag ? flags[flag] : keys(flags)\n      , self = this\n\n    if ($flags) {\n      for (var i = 0, l = $flags.length; i < l; i++) {\n        // avoid recursion\n        if (this.flags[$flags[i]]) continue;\n\n        var name = $flags[i]\n          , assertion = new Assertion(this.obj, name, this)\n  \n        if ('function' == typeof Assertion.prototype[name]) {\n          // clone the function, make sure we dont touch the prot reference\n          var old = this[name];\n          this[name] = function () {\n            return old.apply(self, arguments);\n          }\n\n          for (var fn in Assertion.prototype) {\n            if (Assertion.prototype.hasOwnProperty(fn) && fn != name) {\n              this[name][fn] = bind(assertion[fn], assertion);\n            }\n          }\n        } else {\n          this[name] = assertion;\n        }\n      }\n    }\n  };\n\n  /**\n   * Performs an assertion\n   *\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (truth, msg, error) {\n    var msg = this.flags.not ? error : msg\n      , ok = this.flags.not ? !truth : truth;\n\n    if (!ok) {\n      throw new Error(msg);\n    }\n\n    this.and = new Assertion(this.obj);\n  };\n\n  /**\n   * Check if the value is truthy\n   *\n   * @api public\n   */\n\n  Assertion.prototype.ok = function () {\n    this.assert(\n        !!this.obj\n      , 'expected ' + i(this.obj) + ' to be truthy'\n      , 'expected ' + i(this.obj) + ' to be falsy');\n  };\n\n  /**\n   * Assert that the function throws.\n   *\n   * @param {Function|RegExp} callback, or regexp to match error string against\n   * @api public\n   */\n\n  Assertion.prototype.throwError =\n  Assertion.prototype.throwException = function (fn) {\n    expect(this.obj).to.be.a('function');\n\n    var thrown = false\n      , not = this.flags.not\n\n    try {\n      this.obj();\n    } catch (e) {\n      if ('function' == typeof fn) {\n        fn(e);\n      } else if ('object' == typeof fn) {\n        var subject = 'string' == typeof e ? e : e.message;\n        if (not) {\n          expect(subject).to.not.match(fn);\n        } else {\n          expect(subject).to.match(fn);\n        }\n      }\n      thrown = true;\n    }\n\n    if ('object' == typeof fn && not) {\n      // in the presence of a matcher, ensure the `not` only applies to\n      // the matching.\n      this.flags.not = false; \n    }\n\n    var name = this.obj.name || 'fn';\n    this.assert(\n        thrown\n      , 'expected ' + name + ' to throw an exception'\n      , 'expected ' + name + ' not to throw an exception');\n  };\n\n  /**\n   * Checks if the array is empty.\n   *\n   * @api public\n   */\n\n  Assertion.prototype.empty = function () {\n    var expectation;\n\n    if ('object' == typeof this.obj && null !== this.obj && !isArray(this.obj)) {\n      if ('number' == typeof this.obj.length) {\n        expectation = !this.obj.length;\n      } else {\n        expectation = !keys(this.obj).length;\n      }\n    } else {\n      if ('string' != typeof this.obj) {\n        expect(this.obj).to.be.an('object');\n      }\n\n      expect(this.obj).to.have.property('length');\n      expectation = !this.obj.length;\n    }\n\n    this.assert(\n        expectation\n      , 'expected ' + i(this.obj) + ' to be empty'\n      , 'expected ' + i(this.obj) + ' to not be empty');\n    return this;\n  };\n\n  /**\n   * Checks if the obj exactly equals another.\n   *\n   * @api public\n   */\n\n  Assertion.prototype.be =\n  Assertion.prototype.equal = function (obj) {\n    this.assert(\n        obj === this.obj\n      , 'expected ' + i(this.obj) + ' to equal ' + i(obj)\n      , 'expected ' + i(this.obj) + ' to not equal ' + i(obj));\n    return this;\n  };\n\n  /**\n   * Checks if the obj sortof equals another.\n   *\n   * @api public\n   */\n\n  Assertion.prototype.eql = function (obj) {\n    this.assert(\n        expect.eql(obj, this.obj)\n      , 'expected ' + i(this.obj) + ' to sort of equal ' + i(obj)\n      , 'expected ' + i(this.obj) + ' to sort of not equal ' + i(obj));\n    return this;\n  };\n\n  /**\n   * Assert within start to finish (inclusive). \n   *\n   * @param {Number} start\n   * @param {Number} finish\n   * @api public\n   */\n\n  Assertion.prototype.within = function (start, finish) {\n    var range = start + '..' + finish;\n    this.assert(\n        this.obj >= start && this.obj <= finish\n      , 'expected ' + i(this.obj) + ' to be within ' + range\n      , 'expected ' + i(this.obj) + ' to not be within ' + range);\n    return this;\n  };\n\n  /**\n   * Assert typeof / instance of\n   *\n   * @api public\n   */\n\n  Assertion.prototype.a =\n  Assertion.prototype.an = function (type) {\n    if ('string' == typeof type) {\n      // proper english in error msg\n      var n = /^[aeiou]/.test(type) ? 'n' : '';\n\n      // typeof with support for 'array'\n      this.assert(\n          'array' == type ? isArray(this.obj) :\n            'object' == type\n              ? 'object' == typeof this.obj && null !== this.obj\n              : type == typeof this.obj\n        , 'expected ' + i(this.obj) + ' to be a' + n + ' ' + type\n        , 'expected ' + i(this.obj) + ' not to be a' + n + ' ' + type);\n    } else {\n      // instanceof\n      var name = type.name || 'supplied constructor';\n      this.assert(\n          this.obj instanceof type\n        , 'expected ' + i(this.obj) + ' to be an instance of ' + name\n        , 'expected ' + i(this.obj) + ' not to be an instance of ' + name);\n    }\n\n    return this;\n  };\n\n  /**\n   * Assert numeric value above _n_.\n   *\n   * @param {Number} n\n   * @api public\n   */\n\n  Assertion.prototype.greaterThan =\n  Assertion.prototype.above = function (n) {\n    this.assert(\n        this.obj > n\n      , 'expected ' + i(this.obj) + ' to be above ' + n\n      , 'expected ' + i(this.obj) + ' to be below ' + n);\n    return this;\n  };\n\n  /**\n   * Assert numeric value below _n_.\n   *\n   * @param {Number} n\n   * @api public\n   */\n\n  Assertion.prototype.lessThan =\n  Assertion.prototype.below = function (n) {\n    this.assert(\n        this.obj < n\n      , 'expected ' + i(this.obj) + ' to be below ' + n\n      , 'expected ' + i(this.obj) + ' to be above ' + n);\n    return this;\n  };\n  \n  /**\n   * Assert string value matches _regexp_.\n   *\n   * @param {RegExp} regexp\n   * @api public\n   */\n\n  Assertion.prototype.match = function (regexp) {\n    this.assert(\n        regexp.exec(this.obj)\n      , 'expected ' + i(this.obj) + ' to match ' + regexp\n      , 'expected ' + i(this.obj) + ' not to match ' + regexp);\n    return this;\n  };\n\n  /**\n   * Assert property \"length\" exists and has value of _n_.\n   *\n   * @param {Number} n\n   * @api public\n   */\n\n  Assertion.prototype.length = function (n) {\n    expect(this.obj).to.have.property('length');\n    var len = this.obj.length;\n    this.assert(\n        n == len\n      , 'expected ' + i(this.obj) + ' to have a length of ' + n + ' but got ' + len\n      , 'expected ' + i(this.obj) + ' to not have a length of ' + len);\n    return this;\n  };\n\n  /**\n   * Assert property _name_ exists, with optional _val_.\n   *\n   * @param {String} name\n   * @param {Mixed} val\n   * @api public\n   */\n\n  Assertion.prototype.property = function (name, val) {\n    if (this.flags.own) {\n      this.assert(\n          Object.prototype.hasOwnProperty.call(this.obj, name)\n        , 'expected ' + i(this.obj) + ' to have own property ' + i(name)\n        , 'expected ' + i(this.obj) + ' to not have own property ' + i(name));\n      return this;\n    }\n\n    if (this.flags.not && undefined !== val) {\n      if (undefined === this.obj[name]) {\n        throw new Error(i(this.obj) + ' has no property ' + i(name));\n      }\n    } else {\n      var hasProp;\n      try {\n        hasProp = name in this.obj\n      } catch (e) {\n        hasProp = undefined !== this.obj[name]\n      }\n      \n      this.assert(\n          hasProp\n        , 'expected ' + i(this.obj) + ' to have a property ' + i(name)\n        , 'expected ' + i(this.obj) + ' to not have a property ' + i(name));\n    }\n    \n    if (undefined !== val) {\n      this.assert(\n          val === this.obj[name]\n        , 'expected ' + i(this.obj) + ' to have a property ' + i(name)\n          + ' of ' + i(val) + ', but got ' + i(this.obj[name])\n        , 'expected ' + i(this.obj) + ' to not have a property ' + i(name)\n          + ' of ' + i(val));\n    }\n\n    this.obj = this.obj[name];\n    return this;\n  };\n\n  /**\n   * Assert that the array contains _obj_ or string contains _obj_.\n   *\n   * @param {Mixed} obj|string\n   * @api public\n   */\n\n  Assertion.prototype.string =\n  Assertion.prototype.contain = function (obj) {\n    if ('string' == typeof this.obj) {\n      this.assert(\n          ~this.obj.indexOf(obj)\n        , 'expected ' + i(this.obj) + ' to contain ' + i(obj)\n        , 'expected ' + i(this.obj) + ' to not contain ' + i(obj));\n    } else {\n      this.assert(\n          ~indexOf(this.obj, obj)\n        , 'expected ' + i(this.obj) + ' to contain ' + i(obj)\n        , 'expected ' + i(this.obj) + ' to not contain ' + i(obj));\n    }\n    return this;\n  };\n\n  /**\n   * Assert exact keys or inclusion of keys by using\n   * the `.own` modifier.\n   *\n   * @param {Array|String ...} keys\n   * @api public\n   */\n\n  Assertion.prototype.key =\n  Assertion.prototype.keys = function ($keys) {\n    var str\n      , ok = true;\n\n    $keys = isArray($keys)\n      ? $keys\n      : Array.prototype.slice.call(arguments);\n\n    if (!$keys.length) throw new Error('keys required');\n\n    var actual = keys(this.obj)\n      , len = $keys.length;\n\n    // Inclusion\n    ok = every($keys, function (key) {\n      return ~indexOf(actual, key);\n    });\n\n    // Strict\n    if (!this.flags.not && this.flags.only) {\n      ok = ok && $keys.length == actual.length;\n    }\n\n    // Key string\n    if (len > 1) {\n      $keys = map($keys, function (key) {\n        return i(key);\n      });\n      var last = $keys.pop();\n      str = $keys.join(', ') + ', and ' + last;\n    } else {\n      str = i($keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (!this.flags.only ? 'include ' : 'only have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected ' + i(this.obj) + ' to ' + str\n      , 'expected ' + i(this.obj) + ' to not ' + str);\n\n    return this;\n  };\n\n  /**\n   * Function bind implementation.\n   */\n\n  function bind (fn, scope) {\n    return function () {\n      return fn.apply(scope, arguments);\n    }\n  }\n\n  /**\n   * Array every compatibility\n   *\n   * @see bit.ly/5Fq1N2\n   * @api public\n   */\n\n  function every (arr, fn, thisObj) {\n    var scope = thisObj || global;\n    for (var i = 0, j = arr.length; i < j; ++i) {\n      if (!fn.call(scope, arr[i], i, arr)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Array indexOf compatibility.\n   *\n   * @see bit.ly/a5Dxa2\n   * @api public\n   */\n\n  function indexOf (arr, o, i) {\n    if (Array.prototype.indexOf) {\n      return Array.prototype.indexOf.call(arr, o, i);\n    }\n\n    if (arr.length === undefined) {\n      return -1;\n    }\n\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0\n        ; i < j && arr[i] !== o; i++);\n\n    return j <= i ? -1 : i;\n  };\n\n  /**\n   * Inspects an object.\n   *\n   * @see taken from node.js `util` module (copyright Joyent, MIT license)\n   * @api private\n   */\n\n  function i (obj, showHidden, depth) {\n    var seen = [];\n\n    function stylize (str) {\n      return str;\n    };\n\n    function format (value, recurseTimes) {\n      // Provide a hook for user-specified inspect functions.\n      // Check that value is an object with an inspect function on it\n      if (value && typeof value.inspect === 'function' &&\n          // Filter out the util module, it's inspect function is special\n          value !== exports &&\n          // Also filter out any prototype objects using the circular check.\n          !(value.constructor && value.constructor.prototype === value)) {\n        return value.inspect(recurseTimes);\n      }\n\n      // Primitive types cannot have properties\n      switch (typeof value) {\n        case 'undefined':\n          return stylize('undefined', 'undefined');\n\n        case 'string':\n          var simple = '\\'' + json.stringify(value).replace(/^\"|\"$/g, '')\n                                                   .replace(/'/g, \"\\\\'\")\n                                                   .replace(/\\\\\"/g, '\"') + '\\'';\n          return stylize(simple, 'string');\n\n        case 'number':\n          return stylize('' + value, 'number');\n\n        case 'boolean':\n          return stylize('' + value, 'boolean');\n      }\n      // For some reason typeof null is \"object\", so special case here.\n      if (value === null) {\n        return stylize('null', 'null');\n      }\n\n      // Look up the keys of the object.\n      var visible_keys = keys(value);\n      var $keys = showHidden ? Object.getOwnPropertyNames(value) : visible_keys;\n\n      // Functions without properties can be shortcutted.\n      if (typeof value === 'function' && $keys.length === 0) {\n        if (isRegExp(value)) {\n          return stylize('' + value, 'regexp');\n        } else {\n          var name = value.name ? ': ' + value.name : '';\n          return stylize('[Function' + name + ']', 'special');\n        }\n      }\n\n      // Dates without properties can be shortcutted\n      if (isDate(value) && $keys.length === 0) {\n        return stylize(value.toUTCString(), 'date');\n      }\n\n      var base, type, braces;\n      // Determine the object type\n      if (isArray(value)) {\n        type = 'Array';\n        braces = ['[', ']'];\n      } else {\n        type = 'Object';\n        braces = ['{', '}'];\n      }\n\n      // Make functions say that they are functions\n      if (typeof value === 'function') {\n        var n = value.name ? ': ' + value.name : '';\n        base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n      } else {\n        base = '';\n      }\n\n      // Make dates with properties first say the date\n      if (isDate(value)) {\n        base = ' ' + value.toUTCString();\n      }\n\n      if ($keys.length === 0) {\n        return braces[0] + base + braces[1];\n      }\n\n      if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n          return stylize('' + value, 'regexp');\n        } else {\n          return stylize('[Object]', 'special');\n        }\n      }\n\n      seen.push(value);\n\n      var output = map($keys, function (key) {\n        var name, str;\n        if (value.__lookupGetter__) {\n          if (value.__lookupGetter__(key)) {\n            if (value.__lookupSetter__(key)) {\n              str = stylize('[Getter/Setter]', 'special');\n            } else {\n              str = stylize('[Getter]', 'special');\n            }\n          } else {\n            if (value.__lookupSetter__(key)) {\n              str = stylize('[Setter]', 'special');\n            }\n          }\n        }\n        if (indexOf(visible_keys, key) < 0) {\n          name = '[' + key + ']';\n        }\n        if (!str) {\n          if (indexOf(seen, value[key]) < 0) {\n            if (recurseTimes === null) {\n              str = format(value[key]);\n            } else {\n              str = format(value[key], recurseTimes - 1);\n            }\n            if (str.indexOf('\\n') > -1) {\n              if (isArray(value)) {\n                str = map(str.split('\\n'), function (line) {\n                  return '  ' + line;\n                }).join('\\n').substr(2);\n              } else {\n                str = '\\n' + map(str.split('\\n'), function (line) {\n                  return '   ' + line;\n                }).join('\\n');\n              }\n            }\n          } else {\n            str = stylize('[Circular]', 'special');\n          }\n        }\n        if (typeof name === 'undefined') {\n          if (type === 'Array' && key.match(/^\\d+$/)) {\n            return str;\n          }\n          name = json.stringify('' + key);\n          if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = stylize(name, 'name');\n          } else {\n            name = name.replace(/'/g, \"\\\\'\")\n                       .replace(/\\\\\"/g, '\"')\n                       .replace(/(^\"|\"$)/g, \"'\");\n            name = stylize(name, 'string');\n          }\n        }\n\n        return name + ': ' + str;\n      });\n\n      seen.pop();\n\n      var numLinesEst = 0;\n      var length = reduce(output, function (prev, cur) {\n        numLinesEst++;\n        if (indexOf(cur, '\\n') >= 0) numLinesEst++;\n        return prev + cur.length + 1;\n      }, 0);\n\n      if (length > 50) {\n        output = braces[0] +\n                 (base === '' ? '' : base + '\\n ') +\n                 ' ' +\n                 output.join(',\\n  ') +\n                 ' ' +\n                 braces[1];\n\n      } else {\n        output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n      }\n\n      return output;\n    }\n    return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n  };\n\n  function isArray (ar) {\n    return Object.prototype.toString.call(ar) == '[object Array]';\n  };\n\n  function isRegExp(re) {\n    var s = '' + re;\n    return re instanceof RegExp || // easy case\n           // duck-type for context-switching evalcx case\n           typeof(re) === 'function' &&\n           re.constructor.name === 'RegExp' &&\n           re.compile &&\n           re.test &&\n           re.exec &&\n           s.match(/^\\/.*\\/[gim]{0,3}$/);\n  };\n\n  function isDate(d) {\n    if (d instanceof Date) return true;\n    return false;\n  };\n\n  function keys (obj) {\n    if (Object.keys) {\n      return Object.keys(obj);\n    }\n\n    var keys = [];\n\n    for (var i in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, i)) {\n        keys.push(i);\n      }\n    }\n\n    return keys;\n  }\n\n  function map (arr, mapper, that) {\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, mapper, that);\n    }\n\n    var other= new Array(arr.length);\n\n    for (var i= 0, n = arr.length; i<n; i++)\n      if (i in arr)\n        other[i] = mapper.call(that, arr[i], i, arr);\n\n    return other;\n  };\n\n  function reduce (arr, fun) {\n    if (Array.prototype.reduce) {\n      return Array.prototype.reduce.apply(\n          arr\n        , Array.prototype.slice.call(arguments, 1)\n      );\n    }\n\n    var len = +this.length;\n\n    if (typeof fun !== \"function\")\n      throw new TypeError();\n\n    // no value to return if no initial value and an empty array\n    if (len === 0 && arguments.length === 1)\n      throw new TypeError();\n\n    var i = 0;\n    if (arguments.length >= 2) {\n      var rv = arguments[1];\n    } else {\n      do {\n        if (i in this) {\n          rv = this[i++];\n          break;\n        }\n\n        // if array contains no values, no initial value to return\n        if (++i >= len)\n          throw new TypeError();\n      } while (true);\n    }\n\n    for (; i < len; i++) {\n      if (i in this)\n        rv = fun.call(null, rv, this[i], i, this);\n    }\n\n    return rv;\n  };\n\n  /**\n   * Asserts deep equality\n   *\n   * @see taken from node.js `assert` module (copyright Joyent, MIT license)\n   * @api private\n   */\n\n  expect.eql = function eql (actual, expected) {\n    // 7.1. All identical values are equivalent, as determined by ===.\n    if (actual === expected) { \n      return true;\n    } else if ('undefined' != typeof Buffer \n        && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n      if (actual.length != expected.length) return false;\n\n      for (var i = 0; i < actual.length; i++) {\n        if (actual[i] !== expected[i]) return false;\n      }\n\n      return true;\n\n    // 7.2. If the expected value is a Date object, the actual value is\n    // equivalent if it is also a Date object that refers to the same time.\n    } else if (actual instanceof Date && expected instanceof Date) {\n      return actual.getTime() === expected.getTime();\n\n    // 7.3. Other pairs that do not both pass typeof value == \"object\",\n    // equivalence is determined by ==.\n    } else if (typeof actual != 'object' && typeof expected != 'object') {\n      return actual == expected;\n\n    // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical \"prototype\" property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n    } else {\n      return objEquiv(actual, expected);\n    }\n  }\n\n  function isUndefinedOrNull (value) {\n    return value === null || value === undefined;\n  }\n\n  function isArguments (object) {\n    return Object.prototype.toString.call(object) == '[object Arguments]';\n  }\n\n  function objEquiv (a, b) {\n    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n      return false;\n    // an identical \"prototype\" property.\n    if (a.prototype !== b.prototype) return false;\n    //~~~I've managed to break Object.keys through screwy arguments passing.\n    //   Converting to array solves the problem.\n    if (isArguments(a)) {\n      if (!isArguments(b)) {\n        return false;\n      }\n      a = pSlice.call(a);\n      b = pSlice.call(b);\n      return expect.eql(a, b);\n    }\n    try{\n      var ka = keys(a),\n        kb = keys(b),\n        key, i;\n    } catch (e) {//happens when one is a string literal and the other isn't\n      return false;\n    }\n    // having the same number of owned properties (keys incorporates hasOwnProperty)\n    if (ka.length != kb.length)\n      return false;\n    //the same set of keys (although not necessarily the same order),\n    ka.sort();\n    kb.sort();\n    //~~~cheap key test\n    for (i = ka.length - 1; i >= 0; i--) {\n      if (ka[i] != kb[i])\n        return false;\n    }\n    //equivalent values for every corresponding key, and\n    //~~~possibly expensive deep test\n    for (i = ka.length - 1; i >= 0; i--) {\n      key = ka[i];\n      if (!expect.eql(a[key], b[key]))\n         return false;\n    }\n    return true;\n  }\n\n  var json = (function () {\n    \"use strict\";\n\n    if ('object' == typeof JSON && JSON.parse && JSON.stringify) {\n      return {\n          parse: nativeJSON.parse\n        , stringify: nativeJSON.stringify\n      }\n    }\n\n    var JSON = {};\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 ? '0' + n : n;\n    }\n\n    function date(d, key) {\n      return isFinite(d.valueOf()) ?\n          d.getUTCFullYear()     + '-' +\n          f(d.getUTCMonth() + 1) + '-' +\n          f(d.getUTCDate())      + 'T' +\n          f(d.getUTCHours())     + ':' +\n          f(d.getUTCMinutes())   + ':' +\n          f(d.getUTCSeconds())   + 'Z' : null;\n    };\n\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        gap,\n        indent,\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        },\n        rep;\n\n\n    function quote(string) {\n\n  // If the string contains no control characters, no quote characters, and no\n  // backslash characters, then we can safely slap some quotes around it.\n  // Otherwise we must also replace the offending characters with safe escape\n  // sequences.\n\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ? c :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n  // Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n  // If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value instanceof Date) {\n            value = date(key);\n        }\n\n  // If we were called with a replacer function, then call the replacer to\n  // obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n  // What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n  // JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) ? String(value) : 'null';\n\n        case 'boolean':\n        case 'null':\n\n  // If the value is a boolean or null, convert it to a string. Note:\n  // typeof null does not produce 'null'. The case is included here in\n  // the remote chance that this gets fixed someday.\n\n            return String(value);\n\n  // If the type is 'object', we might be dealing with an object or an array or\n  // null.\n\n        case 'object':\n\n  // Due to a specification blunder in ECMAScript, typeof null is 'object',\n  // so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n  // Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n  // Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n  // The value is an array. Stringify every element. Use null as a placeholder\n  // for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n  // Join all of the elements together, separated with commas, and wrap them in\n  // brackets.\n\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n  // If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === 'string') {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            } else {\n\n  // Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n\n  // Join all of the member texts together, separated with commas,\n  // and wrap them in braces.\n\n            v = partial.length === 0 ? '{}' : gap ?\n                '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n                '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n  // If the JSON object does not yet have a stringify method, give it one.\n\n    JSON.stringify = function (value, replacer, space) {\n\n  // The stringify method takes a value and an optional replacer, and an optional\n  // space parameter, and returns a JSON text. The replacer can be a function\n  // that can replace values, or an array of strings that will select the keys.\n  // A default replacer method can be provided. Use of the space parameter can\n  // produce text that is more easily readable.\n\n        var i;\n        gap = '';\n        indent = '';\n\n  // If the space parameter is a number, make an indent string containing that\n  // many spaces.\n\n        if (typeof space === 'number') {\n            for (i = 0; i < space; i += 1) {\n                indent += ' ';\n            }\n\n  // If the space parameter is a string, it will be used as the indent string.\n\n        } else if (typeof space === 'string') {\n            indent = space;\n        }\n\n  // If there is a replacer, it must be a function or an array.\n  // Otherwise, throw an error.\n\n        rep = replacer;\n        if (replacer && typeof replacer !== 'function' &&\n                (typeof replacer !== 'object' ||\n                typeof replacer.length !== 'number')) {\n            throw new Error('JSON.stringify');\n        }\n\n  // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n\n        return str('', {'': value});\n    };\n\n  // If the JSON object does not yet have a parse method, give it one.\n\n    JSON.parse = function (text, reviver) {\n    // The parse method takes a text and an optional reviver function, and returns\n    // a JavaScript value if the text is a valid JSON text.\n\n        var j;\n\n        function walk(holder, key) {\n\n    // The walk method is used to recursively walk the resulting structure so\n    // that modifications can be made.\n\n            var k, v, value = holder[key];\n            if (value && typeof value === 'object') {\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = walk(value, k);\n                        if (v !== undefined) {\n                            value[k] = v;\n                        } else {\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n            return reviver.call(holder, key, value);\n        }\n\n\n    // Parsing happens in four stages. In the first stage, we replace certain\n    // Unicode characters with escape sequences. JavaScript handles many characters\n    // incorrectly, either silently deleting them, or treating them as line endings.\n\n        text = String(text);\n        cx.lastIndex = 0;\n        if (cx.test(text)) {\n            text = text.replace(cx, function (a) {\n                return '\\\\u' +\n                    ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n            });\n        }\n\n    // In the second stage, we run the text against regular expressions that look\n    // for non-JSON patterns. We are especially concerned with '()' and 'new'\n    // because they can cause invocation, and '=' because it can cause mutation.\n    // But just to be safe, we want to reject all unexpected forms.\n\n    // We split the second stage into 4 regexp operations in order to work around\n    // crippling inefficiencies in IE's and Safari's regexp engines. First we\n    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n    // replace all simple value tokens with ']' characters. Third, we delete all\n    // open brackets that follow a colon or comma or that begin the text. Finally,\n    // we look to see that the remaining characters are only whitespace or ']' or\n    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n        if (/^[\\],:{}\\s]*$/\n                .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                    .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                    .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n    // In the third stage we use the eval function to compile the text into a\n    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n    // in JavaScript: it can begin a block or an object literal. We wrap the text\n    // in parens to eliminate the ambiguity.\n\n            j = eval('(' + text + ')');\n\n    // In the optional fourth stage, we recursively walk the new structure, passing\n    // each name/value pair to a reviver function for possible transformation.\n\n            return typeof reviver === 'function' ?\n                walk({'': j}, '') : j;\n        }\n\n    // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n        throw new SyntaxError('JSON.parse');\n    };\n\n    return JSON;\n  })();\n\n  if ('undefined' != typeof window) {\n    window.expect = module.exports;\n  }\n\n})(\n    this\n  , 'undefined' != typeof module ? module : {}\n  , 'undefined' != typeof exports ? exports : {}\n);\n\n//@ sourceURL=/node_modules/expect.js/expect.js"
));

require.define("/node_modules/iris/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./src/index.js\"}\n//@ sourceURL=/node_modules/iris/package.json"
));

require.define("/node_modules/iris/src/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/// index.js --- Entry point for the Iris package\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = { http:  require('./http')\n                 , jsonp: require('./jsonp') }\n//@ sourceURL=/node_modules/iris/src/index.js"
));

require.define("/node_modules/iris/src/utils.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/// utils.js --- Utilities shared by all iris modules\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module iris.utils\n\n//// -- Aliases ---------------------------------------------------------------\nvar keys   = Object.keys\nvar encode = encodeURIComponent\n\n\n//// --- Utilities ------------------------------------------------------------\nfunction serialise(data) {\n  return keys(data || {}).map(encode_pair).join('&')\n\n  function encode_pair(key) {\n    return encode(key) + '=' + encode(data[key]) }}\n\n\nfunction build_query_string(uri, parameters) {\n  var query = serialise(parameters || {})\n  var sep   = /\\?/.test(uri)?  '&' : '?'\n  return query?           uri + sep + query\n  :      /* otherwise */  uri }\n\n\n//// -- Exports ---------------------------------------------------------------\nmodule.exports = { serialise:          serialise\n                 , build_query_string: build_query_string\n                 }\n//@ sourceURL=/node_modules/iris/src/utils.js"
));

require.define("/node_modules/iris/node_modules/cassie/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./src/cassie.js\"}\n//@ sourceURL=/node_modules/iris/node_modules/cassie/package.json"
));

require.define("/node_modules/iris/node_modules/cassie/src/cassie.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/// cassie.js --- Simple future library for JS. Ready to be raped by Ajax!\n//\n// // Copyright (c) 2011 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module cassie\n\n\f\n//// -- Dependencies --------------------------------------------------------\nvar Base = require('boo').Base\n\n\n\f\n//// -- Aliases -------------------------------------------------------------\nvar slice = [].slice\n\n\n\f\n//// -- Helpers -------------------------------------------------------------\n\n///// Function get_queue\n// Returns a list of callbacks registered for the event.\n//\n// If callbacks ain't defined for the event yet, it's also *initialised*\n// to an empty array.\n//\n// get_queue! :: Promise*, String -> [Fun]\nfunction get_queue(promise, event) {\n  return promise.callbacks[event]\n  ||    (promise.callbacks[event] = []) }\n\n\n///// Function register\n// Creates a function that registers handlers for the given event.\n//\n// register! :: String -> @this:Promise*, Fun -> this\nfunction register(event) { return function(fun) {\n  return this.on(event, fun) }}\n\n\n\f\n//// -- Public interface ----------------------------------------------------\n\n///// Object Promise <| Base\n// A placeholder for a value that can be computed asynchronously.\n//\n// The `Promise' allows any code to define how they'll handle the value\n// before the value is actually computed, by adding listeners to the\n// various events that can be triggered once a promise is fulfilled.\n//\n// Promise :: { \"callbacks\"     -> { String -> [Fun] }\n//            , \"flush_queue\"   -> [Fun]\n//            , \"value\"         -> [Any]\n//            , \"timer\"         -> TimerID\n//            , \"default_event\" -> String\n//            }\nvar Promise = Base.derive({\n  ///// Function init\n  // Initialises an instance of a Promise.\n  //\n  // init! :: @this:Object* -> this\n  init:\n  function _init() {\n    this.callbacks     = {}\n    this.flush_queue   = []\n    this.value         = null\n    this.timer         = null\n    this.default_event = 'done'\n    return this }\n\n\n  ///// Function on\n  // Adds a callback to the given event.\n  //\n  // on! :: @this:Promise*, String, Fun -> this\n, on:\n  function _on(event, callback) {\n    this.default_event = event\n\n    if (this.value)  invoke_callback(this)\n    else             add_callback(this)\n\n    return this\n\n    // Invokes all the callbacks for the event\n    function invoke_callback(promise) {\n      var queue = get_queue(promise, event)\n      return callback && queue.flushed?  callback.apply(promise, promise.value)\n      :      /* otherwise */             null }\n\n    // Adds the callback to the event\n    function add_callback(promise) {\n      return callback?  get_queue(promise, event).push(callback)\n      :                 null }}\n\n\n  ///// Function then\n  // Adds a callback to the active event queue.\n  //\n  // The active event queue is the one for which the last callback was\n  // registered, usually. It is controlled by the internal\n  // `default_event' property.\n  //\n  // then! :: @this:Promise*, Fun -> this\n, then:\n  function _then(callback) {\n    return this.on(this.default_event, callback) }\n\n\n\n  ///// Function flush\n  // Fires all the callbacks for the event.\n  //\n  // If the promise hasn't been resolved yet, the callbacks are placed\n  // in a queue to be flushed once the Promise is fulfilled.\n  //\n  // flush :: @this:Promise*, String -> this\n, flush:\n  function _flush(event) {\n    var self = this\n\n      !this.value?     queue_event(event)\n    : event?           flush_queue(event)\n    : /* otherwise */  flush_all()\n\n    return this\n\n\n    // Adds the event to the flush queue\n    function queue_event(event) {\n      if (event) self.flush_queue.push(event) }\n\n    // Calls all of the callbacks related to a given event\n    function flush_queue(event) {\n      var callbacks = get_queue(self, event)\n\n      callbacks.forEach(function(callback) {\n                          callback.apply(self, self.value) })\n      callbacks.length  = 0\n      callbacks.flushed = true }\n\n    // Calls the callbacks for all events that have been queued\n    function flush_all() {\n      self.flush_queue.forEach(flush_queue) }}\n\n\n  ///// Function done\n  // Fulfills the promise with the values given.\n  //\n  // done :: @this:Promise*, [Any] -> this\n, done:\n  function _done(values) {\n    if (!this.value) {\n      this.clear_timer()\n      this.flush('done')\n      this.value = slice.call(values)\n      this.flush() }\n\n    return this }\n\n\n  ///// Function fail\n  // Fails to fulfill the promise.\n  //\n  // fail :: @this:Promise*, Any... -> this\n, fail:\n  function _fail() {\n    return this.flush('failed').done(arguments) }\n\n\n  ///// Function bind\n  // Successfully fulfills the promise.\n  //\n  // bind :: @this:Promise*, Any... -> this\n, bind:\n  function _bind() {\n    return this.flush('ok').done(arguments) }\n\n\n  ///// Function forget\n  // Cancels the promise.\n  //\n  // forget :: @this:Promise* -> this\n, forget:\n  function _forget() {\n    return this.flush('forgotten').fail('forgotten') }\n\n\n  ///// Function timeout\n  // Schedules the promise to fail after a given number of seconds.\n  //\n  // timeout :: @this:Promise*, Number -> this\n, timeout:\n  function _timeout(delay) {\n    this.clear_timer()\n    this.timer = setTimeout( function(){ this.flush('timeouted')\n                                             .fail('timeouted')  }.bind(this)\n                           , delay * 1000)\n\n    return this }\n\n\n  ///// Function clear_timer\n  // Stop the timer for the promise, if one was previously set by\n  // invoking `timeout'.\n  //\n  // clear_timer :: @this:Promise* -> this\n, clear_timer:\n  function _clear_timer() {\n    clearTimeout(this.timer)\n    this.timer = null\n    return this }\n\n\n  ///// Function ok\n  // Registers a callback for when the promise is successfully\n  // fulfilled.\n  //\n  // ok :: @this:Promise*, Fun -> this\n, ok: register('ok')\n\n  ///// Function failed\n  // Registers a callback for when the promise fails to be fulfilled.\n  //\n  // failed :: @this:Promise*, Fun -> this\n, failed: register('failed')\n\n  ///// Function timeouted\n  // Registers a callback for when the promise fails by timing out.\n  //\n  // timeouted :: @this:Promise*, Fun -> this\n, timeouted: register('timeouted')\n\n  ///// Function forgotten\n  // Registers a callback for when the promise fails by being\n  // cancelled.\n  //\n  // forgotten :: @this:Promise*, Fun -> this\n, forgotten: register('forgotten')\n})\n\n\n\f\n//// -- Exports ---------------------------------------------------------------\nmodule.exports = { Promise   : Promise\n                 , register  : register\n\n                 , internals : { get_queue: get_queue }}\n\n//@ sourceURL=/node_modules/iris/node_modules/cassie/src/cassie.js"
));

require.define("/node_modules/iris/node_modules/boo/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./src/boo.js\"}\n//@ sourceURL=/node_modules/iris/node_modules/boo/package.json"
));

require.define("/node_modules/iris/node_modules/boo/src/boo.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/// boo.js --- Prototypical utilities\n//\n// Copyright (c) 2011 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module boo\nvoid function(root, exports) {\n  var slice   = [].slice\n    , keys    = Object.keys\n    , inherit = Object.create\n\n\n  \f\n  //// - Interfaces -----------------------------------------------------------\n\n  ///// Interface DataObject\n  // :: { \"to_data\" -> () -> Object }\n\n\n  \f\n  //// - Helpers --------------------------------------------------------------\n\n  ///// Function data_obj_p\n  // :internal:\n  // Checks if the given subject matches the DataObject interface\n  //\n  // data_obj_p :: Any -> Bool\n  function data_obj_p(subject) {\n    return subject != null\n    &&     typeof subject.to_data == 'function' }\n\n\n  ///// Function resolve_mixins\n  // :internal:\n  // Returns the proper mixin for the given object.\n  //\n  // resolve_mixin :: Object -> Object\n  function resolve_mixin(object) {\n    return data_obj_p(object)?  object.to_data()\n    :                           object }\n\n\n  ///// Function fast_extend\n  // :internal:\n  // Extends the target object with the provided mixins, using a\n  // right-most precedence rule  when a there's a property conflict, the\n  // property defined in the last object wins.\n  //\n  // `DataObject's are properly handled by the `resolve_mixin'\n  // function.\n  //\n  // :warning: low-level\n  //    This function is not meant to be called directly from end-user\n  //    code, use the `extend' function instead.\n  //\n  // fast_extend :: Object, [Object | DataObject] -> Object\n  function fast_extend(object, mixins) {\n    var i, j, len, mixin, props, key\n    for (i = 0, len = mixins.length; i < len; ++i) {\n      mixin = resolve_mixin(mixins[i])\n      props = keys(mixin)\n      for (j = props.length; j--;) {\n        key         = props[j]\n        object[key] = mixin[key] }}\n\n    return object }\n\n\n  \f\n  //// - Basic primitives -----------------------------------------------------\n\n  ///// Function extend\n  // Extends the target object with the provided mixins, using a\n  // right-most precedence rule.\n  //\n  // :see-also:\n  //   - `fast_extend'  lower level function.\n  //   - `merge'        pure version.\n  //\n  // extend :: Object, (Object | DataObject)... -> Object\n  function extend(target) {\n    return fast_extend(target, slice.call(arguments, 1)) }\n\n\n  ///// Function merge\n  // Creates a new object that merges the provided mixins, using a\n  // right-most precedence rule.\n  //\n  // :see-also:\n  //   - `extend'  impure version.\n  //\n  // merge :: (Object | DataObject)... -> Object\n  function merge() {\n    return fast_extend({}, arguments) }\n\n  ///// Function derive\n  // Creates a new object inheriting from the given prototype and extends\n  // the new instance with the provided mixins.\n  //\n  // derive :: Object, (Object | DataObject)... -> Object\n  function derive(proto) {\n    return fast_extend(inherit(proto), slice.call(arguments, 1)) }\n\n\n  \f\n  //// - Root object ----------------------------------------------------------\n\n  ///// Object Base\n  // The root object for basing all the OOP code. Provides the previous\n  // primitive combinators in an easy and OOP-way.\n  var Base = {\n\n    ////// Function make\n    // Constructs new instances of the object the function is being\n    // applied to.\n    //\n    // If the object provides an ``init`` function, that function is\n    // invoked to do initialisation on the new instance.\n    //\n    // make :: Any... -> Object\n    make:\n    function _make() {\n      var result = inherit(this)\n      if (typeof result.init == 'function')\n        result.init.apply(result, arguments)\n\n      return result }\n\n    ////// Function derive\n    // Constructs a new object that inherits from the object this function\n    // is being applied to, and extends it with the provided mixins.\n    //\n    // derive :: (Object | DataObject)... -> Object\n  , derive:\n    function _derive() {\n      return fast_extend(inherit(this), arguments) }}\n\n\n  \f\n  //// - Exports --------------------------------------------------------------\n  exports.extend   = extend\n  exports.merge    = merge\n  exports.derive   = derive\n  exports.Base     = Base\n  exports.internal = { data_obj_p    : data_obj_p\n                     , fast_extend   : fast_extend\n                     , resolve_mixin : resolve_mixin\n                     }\n\n}\n( this\n, typeof exports == 'undefined'? this.boo = this.boo || {}\n  /* otherwise, yay modules! */: exports\n)\n//@ sourceURL=/node_modules/iris/node_modules/boo/src/boo.js"
));

require.define("/node_modules/iris/src/jsonp.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/// jsonp.js --- Abstracts over JSONP requests\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module iris.jsonp\n\n//// -- Dependencies ----------------------------------------------------------\nvar utils  = require('./utils')\nvar cassie = require('cassie')\n\n\n//// -- Aliases ---------------------------------------------------------------\nvar keys               = Object.keys\nvar call               = Function.call\nvar to_array           = call.bind([].slice)\nvar build_query_string = utils.build_query_string\nvar Promise            = cassie.Promise\n\n\n//// -- Helpers ---------------------------------------------------------------\nwindow.__iris_callbacks__ = { }\nvar id_poll = []\nvar request_id = 0\n\nvar head = document.getElementsByTagName('head')[0]\n\nfunction get_callback() {\n  return id_poll.length?  'f' + id_poll.pop()\n  :      /* otherwise */  'f' + ++request_id }\n\nfunction noop() { }\n\n//// -- Public interface ------------------------------------------------------\nvar active = []\n\nvar PromiseP = Promise.derive({\n  init:\n  function _init(uri, callback, options) {\n    Promise.init.call(this)\n    this.uri      = uri\n    this.options  = options\n    this.callback = callback\n\n    return this }\n})\n\nfunction request(uri, options) {\n  options = options || {}\n  options.query = options.query || {}\n\n  var callback_field = options.query.callback || 'callback'\n  var callback = get_callback()\n  var script = document.createElement('script')\n  var promise = PromiseP.make(uri, callback, options)\n\n  active.push(promise)\n\n  __iris_callbacks__[callback] = promise.bind.bind(promise)\n  script.onerror = promise.fail.bind(promise)\n\n  promise.on('done', clean)\n\n  options.query[callback_field] = '__iris_callbacks__.' + callback\n  script.src = build_query_string(uri, options.query)\n  script.async = true\n\n  head.appendChild(script)\n\n  return promise\n\n  function clean() {\n    active.splice(active.indexOf(promise), 1)\n    id_poll.push(callback.slice(1))\n    __iris_callbacks__[callback] = noop\n    script.parentNode.removeChild(script) }\n}\n\n\n//// -- Exports ---------------------------------------------------------------\nmodule.exports = { PromiseP: PromiseP\n                 , request:  request\n                 , active:   active }\n//@ sourceURL=/node_modules/iris/src/jsonp.js"
));

require.define("/node_modules/iris/src/http.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/// http.js --- Deals with HTTP requests in the browser\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module iris.http\n\n//// -- Dependencies ----------------------------------------------------------\nvar utils  = require('./utils')\nvar cassie = require('cassie')\n\n\n//// -- Aliases ---------------------------------------------------------------\nvar keys               = Object.keys\nvar call               = Function.prototype.call\nvar to_array           = call.bind([].slice)\nvar class_of           = call.bind({}.toString)\nvar serialise          = utils.serialise\nvar build_query_string = utils.build_query_string\nvar register           = cassie.register\nvar Promise            = cassie.Promise\n\n\n//// -- Helpers ---------------------------------------------------------------\nvar make_xhr = function() {\n                 return 'XMLHttpRequest' in this?\n                        /* W3C? */ function() {\n                                     return new XMLHttpRequest() }\n                        :\n                        /* IE? */  function() {\n                                     return new ActiveXObject('Microsoft.XMLHTTP') }}()\n\nvar support_timeout_p = 'timeout' in make_xhr()\n\nvar success = /2\\d{2}/\nvar error   = /[45]\\d{2}/\n\nvar statuses = [ 'information'\n               , 'success'\n               , 'redirected'\n               , 'client-error'\n               , 'server-error' ]\n\nvar state_map = [ 'unsent'\n                , 'opened'\n                , 'headers-received'\n                , 'loading'\n                , 'completed' ]\n\nfunction object_p(subject) {\n  return class_of(subject) == '[object Object]' }\n\nfunction status_type(status) {\n  var type = status.toString().charAt(0) - 1\n  return statuses[type] }\n\nfunction serialise_for_type(mime, data) {\n  return mime == 'application/json'?  JSON.stringify(data)\n  :      /* otherwise */              serialise(data) }\n\n\n//// -- Public interface ------------------------------------------------------\nvar active = []\n\nvar PromiseP = Promise.derive({\n  init:\n  function _init(client, uri, options) {\n    Promise.init.call(this)\n    this.client  = client\n    this.uri     = uri\n    this.options = options\n\n    return this }\n\n, fire:\n  function _fire(event) {\n    var args, callbacks, i, len\n    args      = to_array(arguments, 1)\n    callbacks = this.callbacks[event] || []\n\n    for (i = 0, len = callbacks.length; i < len; ++i)\n      callbacks[i].apply(this, args)\n\n    return this }\n\n, forget:\n  function _forget() {\n    this.client.abort()\n    return Promise.forget.call(this) }\n\n, timeout: support_timeout_p?  function _timeout(delay) {\n                                 this.timeout = delay * 1000\n                                 return this }\n\n         : /* otherwise */     function _timeout(delay) {\n                                 this.clear_timer()\n                                 this.timer = setTimeout( function() {\n                                                            this.abort()\n                                                            this.flush('timeouted')\n                                                                .fail(Promise.TIMEOUTED) }.bind(this)\n                                                        , delay * 1000 )}\n\n, clear_timer: support_timeout_p?  function _clear_timer() {\n                                     this.timeout = 0\n                                     return this }\n\n             : /* otherwise */     Promise.clear_timer\n\n// Generalised HTTP statuses\n, information  : register('status:information')\n, success      : register('status:success')\n, redirected   : register('status:redirected')\n, client_error : register('status:client-error')\n, server_error : register('status:server-error')\n\n// Ready states\n, unsent           : register('state:unsent')\n, opened           : register('state:opened')\n, headers_received : register('state:headers-received')\n, loading          : register('state:loading')\n, completed        : register('state:completed')\n})\n\n\n\nfunction request(uri, options) {\n  var client, promise, method, serialise_body_p, mime\n  options          = options         || {}\n  options.headers  = options.headers || {}\n  method           = (options.method || 'GET').toUpperCase()\n  uri              = build_uri(uri, options.query, options.body)\n\n  options.headers['X-Requested-With'] = 'XMLHttpRequest'\n\n  serialise_body_p = object_p(options.body)\n  if (serialise_body_p) {\n    mime = options.headers['Content-Type'] || 'application/x-www-form-urlencoded'\n    options.body = serialise_for_type(mime, options.body)\n    options.headers['Content-Type'] = mime }\n\n  client  = make_xhr()\n  promise = PromiseP.make(client, uri, options)\n\n  setup_listeners()\n\n  setTimeout(function() {\n    client.open(method, uri, true, options.username, options.password)\n    setup_headers(options.headers || {})\n    client.send(options.body) })\n\n  active.push(promise)\n\n  return promise\n\n\n  function build_uri(uri, query, body) {\n    uri = build_query_string(uri, query)\n    return method == 'GET'?  build_query_string(uri, body)\n    :      /* otherwise */   uri }\n\n  function setup_headers(headers) {\n    keys(headers).forEach(function(key) {\n      client.setRequestHeader(key, headers[key]) })}\n\n  function setup_listeners() {\n    client.onerror            = function(ev){ promise.fail('errored', ev)       }\n    client.onabort            = function(ev){ promise.fail('aborted', ev)       }\n    client.ontimeout          = function(ev){ promise.fail('timeouted', ev)     }\n    client.onloadstart        = function(ev){ promise.fire('load:start', ev)    }\n    client.onprogress         = function(ev){ promise.fire('load:progress', ev) }\n    client.onloadend          = function(ev){ promise.fire('load:end', ev)      }\n    client.onload             = function(ev){ promise.fire('load:success', ev)  }\n    client.onreadystatechange = function(  ){\n                                  var response, status, state\n                                  response = client.responseText\n                                  state    = client.readyState\n\n                                  promise.fire('state:' + state_map[state], response, status)\n\n                                  if (state == 4) {\n                                    status   = client.status\n                                    active.splice(active.indexOf(promise), 1)\n                                    promise.flush('status:' + status)\n                                           .flush('status:' + status_type(status))\n\n                                      success.test(status)?  promise.bind(response, status)\n                                    : error.test(status)?    promise.fail(response, status)\n                                    : /* otherwise */        promise.done([response, status]) }}}\n}\n\n\nfunction request_with_method(method) { return function(uri, options) {\n  options = options || { }\n  options.method = method.toUpperCase()\n  return request(uri, options) }}\n\n\n//// -- Exports ---------------------------------------------------------------\nmodule.exports = { PromiseP: PromiseP\n                 , request:  request\n                 , active:   active\n                 , get:      request_with_method('GET')\n                 , post:     request_with_method('POST')\n                 , put:      request_with_method('PUT')\n                 , head:     request_with_method('HEAD')\n                 , delete_:  request_with_method('DELETE')\n                 , options:  request_with_method('OPTIONS')\n\n                 , internal: { make_xhr: make_xhr }}\n\n//@ sourceURL=/node_modules/iris/src/http.js"
));

require.define("/http.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var expect = require('expect.js')\n\ndescribe('{} iris', function() {\ndescribe('{} http', function() {\n  var http  = require('iris').http\n  var proto = Object.getPrototypeOf\n  var ok    = false\n\n  var statuses = zipRange('success',      200, 206).concat(\n                   zipRange('redirected',   300, 307).concat(\n                     zipRange('client-error', 400, 417).concat(\n                       zipRange('server-error', 500, 505))))\n\n  function without_args(f){ return function() { return f() }}\n\n  function each(xs, f, done) {\n    var i = 0\n    step()\n\n    function step() {\n      if (i < xs.length) f(xs[i++], step)\n      else               done() }}\n\n  function zipRange(pre, start, end) {\n    var xs = range(start, end)\n    return xs.map(function(x){ return [pre, x] })}\n\n  function range(start, end) {\n    var xs = []\n    --start\n    while (++start <= end) xs.push(start)\n    return xs }\n\n  function success() { ok = true }\n  function failure() { ok = false }\n\n  function http_done(p, step) { return function() {\n    if (p.client.status == 0)\n      console.log(p.client.status, 'Request failed', p)\n    else\n      expect(ok).to.be.ok()\n    step() }}\n\n  beforeEach(function() {\n    ok = false\n  })\n\n  describe(' request', function() {\n    describe(' Pre and post conditions ', function() {\n      it('Should return a PromiseP object.', function(next) {\n        var p = http.request('/no-op').on('done', without_args(next))\n        expect(proto(p)).to.be(http.PromiseP)\n      })\n      it('Should add the promise to the list of active requests.', function(next) {\n        var p = http.request('/no-op').headers_received(function(){\n          expect(http.active).to.contain(p)\n          p.forget()\n          next()\n        })\n\n      })\n\n      it('Should, when done, remove the promise from the list of active requests.', function(next) {\n        var p = http.request('/no-op').ok(function() {\n                                            expect(http.active).to.not.contain(p) })\n                                      .on('done', without_args(next))\n      })\n    })\n\n    describe(' Headers and other meta information ', function() {\n      it('Should use GET as the default method.', function(next) {\n        http.get('/method').ok(function(data) {\n          expect(data).to.be('GET')\n          next()\n        })\n      })\n      it('Should serialise the #query object in the URI.', function(next) {\n        http.get('/query', {query: {a: 1, b: 2, c: 3}}).ok(function(data) {\n          data = JSON.parse(data)\n          expect(data).to.eql({a: 1, b: 2, c: 3})\n          next()\n        })\n      })\n      it('Should serialise the #body object in the URI for GET requests.', function(next) {\n        http.get('/query', {query: {a: 1 }, body: { b: 2, c: 3}}).ok(function(data) {\n          data = JSON.parse(data)\n          expect(data).to.eql({a:1, b:2, c: 3})\n          next()\n        })\n      })\n      it('Should serialise the #body object in the request\\'s body otherwise.', function(next) {\n        http.post('/body', {body: {a:1, b:2, c:3}}).ok(function(data) {\n          data = JSON.parse(data)\n          expect(data).to.eql({a:1, b:2, c:3})\n          next()\n        })\n      })\n      it('Should use JSON for body encoding when the content-type dictates it.', function(next) {\n        http.post('/body', { body: {a:1, b:2, c:3}\n                           , headers: { 'Content-Type': 'application/json' }})\n            .ok(function(data) {\n              data = JSON.parse(data)\n              expect(data).to.eql({a:1, b:2, c:3})\n              next()\n            })\n      })\n      it('Should set the HTTP headers given in the request.', function(next) {\n        http.get('/headers', { headers: { 'Content-Type': 'application/json'\n                                        , 'Accept':       'application/json' }})\n            .ok(function(data) {\n              data = JSON.parse(data)\n              expect(data).to.contain('content-type')\n              expect(data).to.contain('accept')\n              expect(data).to.contain('x-requested-with')\n              next()\n            })\n      })\n      it('Should pass the username and password options, if given.')\n    })\n\n\n    describe(' Responses ', function() {\n      it('Should execute all callbacks matching the generic HTTP status type.', function(next) {\n        each( statuses\n            , function(item, step) {\n                var type   = item[0]\n                var status = item[1]\n                var p = http.get('/status/' + status)\n                p.on('status:' + type, success)\n                 .on('done',           http_done(p, step)) }\n            , next)\n      })\n      it('Should execute all callbacks matching the exact HTTP response status.', function(next) {\n        each( statuses\n            , function(item, step) {\n                var type   = item[0]\n                var status = item[1]\n                var p = http.get('/status/' + status)\n                p.on('status:' + status, success)\n                 .on('done',             http_done(p, step)) }\n            , next)\n      })\n      it('Should execute the success callbacks in case of a 2xx.', function(next) {\n        each( range(200, 206)\n            , function(status, step) {\n                var p = http.get('/status/' + status)\n                p.ok(success).failed(failure)\n                 .on('done', http_done(p, step)) }\n            , next)\n      })\n      it('Should execute all failure callbacks in case of a 4xx or 5xx.', function(next) {\n        each( range(400, 417).concat(range(500, 505))\n            , function(status, step) {\n                var p = http.get('/status/' + status)\n                p.failed(success).ok(failure)\n                 .on('done', http_done(p, step)) }\n            , next)\n      })\n      it('Shouldn\\'t execute success or failure callbacks in case of 1xx or 3xx.', function(next) {\n        each( range(300, 307)\n            , function(status, step) {\n                ok = true\n                var p = http.get('/status/' + status)\n                p.ok(failure).failed(failure)\n                 .on('done', http_done(p, step)) }\n            , next)\n      })\n      it('Should pass the response and status as parameters of the callbacks.', function(next) {\n        http.get('/response')\n            .ok(success).failed(failure)\n            .on('done', function(data, status) {\n                          expect(ok).to.be.ok()\n                          expect(data).to.be('response.')\n                          expect(status).to.be(200)\n                          next() })\n      })\n    })\n\n    describe(' Events ', function() {\n      it('Should execute all callbacks from state X when the request enters that state.')\n      it('Should execute all abort callbacks when the request is aborted.')\n      it('Should set the promise\\'s value to `aborted\\' when aborted.')\n      it('Should execute all timeout callbacks when the request times out.')\n      it('Should set the promise\\'s value to `timeouted\\' when timeouted.')\n      it('Should execute the `error\\' callbacks if an error occurs with the request itself.')\n    })\n\n    describe(' XHR2 Events ', function() {\n      it('Should execute the `load:start\\' callbacks when loading starts.')\n      it('Should execute the `load:progress\\' callbacks anytime we receive new chunks.')\n      it('Should execute the `load:end\\' callbacks when loading finishes.')\n      it('Should execute the `load:success\\' callbacks when we fully receive the request.')\n    })\n  })\n})\n})\n//@ sourceURL=/http.js"
));

require.define("/suite.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "require('./http.js')\n\n//@ sourceURL=/suite.js"
));
require("/suite.js");
